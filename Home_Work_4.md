# Домашнее задание к занятию «Операционные системы. Лекция 2»



### Чеклист готовности к домашнему заданию

1. Убедитесь, что у вас установлен [Netdata](https://github.com/netdata/netdata) c ресурса с предподготовленными [пакетами](https://packagecloud.io/netdata/netdata/install) или `sudo apt install -y netdata`.


### Дополнительные материалы для выполнения задания

1. [Документация](https://www.freedesktop.org/software/systemd/man/systemd.service.html) по systemd unit-файлам.
2. [Документация](https://www.kernel.org/doc/Documentation/sysctl/) по параметрам sysctl.

------

## Задание

1. На лекции вы познакомились с [node_exporter](https://github.com/prometheus/node_exporter/releases). В демонстрации его исполняемый файл запускался в background. Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним управлением. Используя знания из лекции по systemd, создайте самостоятельно простой [unit-файл](https://www.freedesktop.org/software/systemd/man/systemd.service.html) для node_exporter:

    * поместите его в автозагрузку;
    * предусмотрите возможность добавления опций к запускаемому процессу через внешний файл (посмотрите, например, на `systemctl cat cron`);
    * удостоверьтесь, что с помощью systemctl процесс корректно стартует, завершается, а после перезагрузки автоматически поднимается.

### Ответ: 
Создадим unit файл для node-exporter, с учётом возможности дополнительных опций указать в файле
*  ![изображение](https://user-images.githubusercontent.com/123881243/226596690-ca6c158a-7d06-46f2-b8d0-1b8437394e7f.png)

Добавим в автозагрузку:
*  ![изображение](https://user-images.githubusercontent.com/123881243/226355056-42932a23-bdc7-431e-a8c0-ecddcb1300fe.png)

Проверим состояние, запустился ли процесс:
*   ![изображение](https://user-images.githubusercontent.com/123881243/226595878-8ee501cd-d80c-4304-8efb-ddb9fce35047.png)

Проверим запуск после перезагрузки VM:
*  ![изображение](https://user-images.githubusercontent.com/123881243/226597179-dfe64832-fadf-4d3f-83ca-d2dbbe579e5d.png)

Остановим и заново запустим процесс, в realtime:
*  ![изображение](https://user-images.githubusercontent.com/123881243/226597532-f2ccfa6a-f822-4888-b5d0-9e67f3102fec.png)

1. Изучите опции node_exporter и вывод `/metrics` по умолчанию. Приведите несколько опций, которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.
CPU,также исходя из того, если будет высокое значения времени iowait это может означать, что в системе узким местом является дискова подсистема или же проблемы в сети. 
![изображение](https://user-images.githubusercontent.com/123881243/226625883-d6e6513e-44eb-4cec-8f0c-f618d5574569.png)
Дисковая подсистема:
![изображение](https://user-images.githubusercontent.com/123881243/226628298-cb4e29b9-1068-4c27-803e-dd50c7d61f65.png)
Сеть:

 ![изображение](https://user-images.githubusercontent.com/123881243/226625336-3859e23e-a7d2-4543-a2d6-aa6e332397ec.png)

`И всё тоже самое для tx направления.`

Память:
![изображение](https://user-images.githubusercontent.com/123881243/226627839-f7d465bd-5123-4e3f-8924-ed20615b80b3.png)

2. Установите в свою виртуальную машину [Netdata](https://github.com/netdata/netdata). Воспользуйтесь [готовыми пакетами](https://packagecloud.io/netdata/netdata/install) для установки (`sudo apt install -y netdata`). 
   
   После успешной установки:
   
    * в конфигурационном файле `/etc/netdata/netdata.conf` в секции [web] замените значение с localhost на `bind to = 0.0.0.0`;
    * добавьте в Vagrantfile проброс порта Netdata на свой локальный компьютер и сделайте `vagrant reload`:

    ```bash
    config.vm.network "forwarded_port", guest: 19999, host: 19999
    ```

    После успешной перезагрузки в браузере на своём ПК (не в виртуальной машине) вы должны суметь зайти на `localhost:19999`. Ознакомьтесь с метриками, которые по умолчанию собираются Netdata, и с комментариями, которые даны к этим метрикам.

### Ответ:
Я пошёл немного другим путём, так как NAT на VM не совсем удобен для меня. Поэтому я создал ещё один сетевой интерфейс типа Br и напрямую через свой сегмент сети попадаю на VM
![изображение](https://user-images.githubusercontent.com/123881243/226679439-70f66893-cbe9-44ad-a182-cbe0e094b792.png)

Таким образом я выполняю вход на VM до сервиса netdata, после изменений в конфигурации `bind to = 0.0.0.0` через локальный адрес 192.168.5.110
![изображение](https://user-images.githubusercontent.com/123881243/226680149-c938452b-9a51-4b7a-a7b2-a99be313341b.png)

3. Можно ли по выводу `dmesg` понять, осознаёт ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?

### Ответ: 
Да, вывод в скриншоте:

![изображение](https://user-images.githubusercontent.com/123881243/226680489-628beccc-c2b6-442c-88bc-267b777b19f2.png)

4. Как настроен sysctl `fs.nr_open` на системе по умолчанию? Определите, что означает этот параметр. Какой другой существующий лимит не позволит достичь такого числа (`ulimit --help`)?

### Ответ:
fs.nr_open лимит по умолчанию равен 1048576, это лимит открытых файлов для каждого отдельного процесса
![изображение](https://user-images.githubusercontent.com/123881243/226707472-8a83e8ee-a238-46fc-812a-ddab164eed5c.png)


5. Запустите любой долгоживущий процесс (не `ls`, который отработает мгновенно, а, например, `sleep 1h`) в отдельном неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через `nsenter`. Для простоты работайте в этом задании под root (`sudo -i`). Под обычным пользователем требуются дополнительные опции (`--map-root-user`) и т. д.

### Ответ:
![изображение](https://user-images.githubusercontent.com/123881243/226983595-9ff5f390-1f79-4ff9-87f5-bdb0322fda1f.png)

6. Найдите информацию о том, что такое `:(){ :|:& };:`. Запустите эту команду в своей виртуальной машине Vagrant с Ubuntu 20.04 (**это важно, поведение в других ОС не проверялось**). Некоторое время всё будет плохо, после чего (спустя минуты) — ОС должна стабилизироваться. Вызов `dmesg` расскажет, какой механизм помог автоматической стабилизации.  
Как настроен этот механизм по умолчанию, и как изменить число процессов, которое можно создать в сессии?
### Ответ:
![изображение](https://user-images.githubusercontent.com/123881243/226871263-0983a842-7413-4681-bbf4-eb4e1a91561b.png)

Это маленькая программа, которую можно расценивать как DOS атака, она порождает child process n-раз,с помощью системного вызова fork,тем самым довольно скоро приводит систему в нерабочее состояние, исчерпав ресурсы.
Защититься от неё можно задав лимиты на открытие процессов для всей системы или для конкретного пользователя:
По умолчанию он настроен так:

![изображение](https://user-images.githubusercontent.com/123881243/226722447-9e6869a7-dda6-4d79-bfc1-6de65ee86045.png)

Если говорить про временное ограничение для пользователя, то задать его можно в рамках жесткого лимита, но не выше через команду `ulimit -u 5000`, чтобы проверить какой лимит выше которого мы не сможем установить значение нужно ввести команду  `ulimit -Hu`.  
Или чтобы огранчиения были постоянными задать их в файле: /etc/security/limits.conf
Ниже разберём вкратце синтаксис 

```

# <domain> <type> <item> <value>
Вкратце разберем каждое из полей.
•	domain: имена пользователей, группы, диапазоны GUID и т. д.
•	type: Тип лимита (мягкий/жесткий)
•	item: ресурс, который будет ограничен, например, размер ядра, nproc, размер файла и т. д.
•	value: предельное значение
Также краткий список всех доступных предметов.
•	core: ограничивает размер основного файла (в КБ)
•	cpu: время процессора (в мин.)
•	data: размер данных (в КБ)
•	fsize: Размер файла (в КБ)
•	locks: блокировка файлов, которую пользователь может удерживать
•	memlock: заблокированное адресное пространство в памяти (в КБ)
•	nproc: количество процессоров
•	rtpio: приоритет в реальном времени
•	sigpending: Количество ожидающих сигналов
```
В dmesg видим:
![изображение](https://user-images.githubusercontent.com/123881243/226871392-32a62e5d-9f9e-4003-8b5c-2180312f4db2.png)
Это cgroups. Контрольная группа, механизм позволяет образовывать иерархические группы процессов с заданными ресурсными свойствами и обеспечивает программное управление ими.
В итоге один из контроллеров подсистем pids Process Number Controller, способствовал стабилизации системы 


